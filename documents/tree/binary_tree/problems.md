#### 记录一些常见的二叉树（面试）问题 ####

>  关于树的递归，递归函数的传参一般都是另一个树的根节点（也就是以左右子树的根节点为传参），一般简单的递归模式是“一个树的求解结果等于其左右子树分别的求解结果的简单逻辑运算”，但是也有可能一个问题是多重递归
>
> 一般来讲，简单二叉树的节点都没有父节点指针，BST的节点才有父节点指针

##### 求二叉树中两个节点的最近公共祖先 #####

当二叉树为二叉搜索树时，问题变得简单一些。因为我们需要找到**第一个两个已知节点分别处于其左子树和右子树的子树的根节点**；在二叉搜索树中，如果这种情况发生，那么*根节点的值的大小会处于两个已知节点的中间*。所以我们只需要**从根节点开始**比较根节点与两个已知节点的值，如果根节点大于两个已知节点，那么就用左儿子继续与两个已知节点比较；如果根节点小于两个已知节点，那么就用右儿子继续与两个已知节点比较；递归进行，直到找到第一个大小在两个已知节点之间的节点，并返回。

当二叉树为一般的二叉树时（也适用于一般的树），情况变得比较麻烦。我们可以忽略其它所有的节点，只剩下两个节点到根节点的路径上的节点，此时问题就变成了**求一个Y字形交叉链表的第一个公共节点**，我们只需要知道从两个已知节点分别到根节点的路径长度。此时我们得到了一个路径长度差，然后我们**设置两个起始位置指针（起始位置为两个已知节点，向根节点的方向移动），并使较长的路径上的起始指针先走两条路径的长度差个位置，然后两个指针同时一步步前进，并返回两指针指向的第一个相同节点**。如果每个节点中存在一个指向父节点的指针，上述思路即可解决问题。否则我们需要使用一个栈分别将从根节点到两个已知节点的路径记录下来，然后同样将较长路径的栈先 pop 出两条路径相差的个数的节点，然后一起 pop，并返回第一个 pop 出来相同的节点。

> 因为一般的二叉树节点没有父节点指针，需要递归求 root 到对应两个节点的路径之后，在进行“求链表公共节点”的操作

##### 求二叉树中两个节点的距离 #####

可以转化成求最近公共祖先的问题（添加一些计数器即可），可能需要找出root到节点的路径（可以用递归）；

##### 求二叉树中任意两个节点的最大距离 #####

我们需要意识到，最大距离只可能存在两个节点都为叶子节点的时候。然后问题就变成了**求一个树中某个节点的左右子树高度最大和**的问题。我们需要遍历每个节点，求每个左右子树高度和加1，并维持一个最大值的记录，然后输出该记录即可。（不一定是根结点的左右子树高度之和，比如非常不平衡的时候）

##### 判断二叉树是否对称 #####

对于一个节点，判断以其为根节点的树是否镜像对称，即判断左右子树是否对称。我们可以很简单地想到递归的思路去做这个问题，即先判断左儿子和右儿子是否相等（或是否同时为空），再递归地判断左儿子的左子树和右儿子的右子树是否对称以及左儿子的右子树和右儿子的左子树是否对称。

一定要有两个函数，一个函数为主函数不递归，参数为一个树的 root 节点，返回一个 bool 值；另一个辅助函数为递归函数，递归函数传入的参数是左右子树的根节点，每次递归返回的结果是 “左儿子的左子树和右儿子的右子树是否对称 以及 左儿子的右子树和右儿子的左子树是否对称”

> 或者前序遍历以及反方向前序遍历（RLD），把值记录下来，逐个看看值是不是相同

##### 给定一个整数二叉树，求有多少条路径节点值的和等于给定值

> 注意，这个路径不一定要是以根节点为起始节点

首先，一个树有多少个路径不仅仅是其左右子树分别有多少个路径之和，除了“左右子树分别有多少个路径之和”，还需要考虑以“树的根节点为起始节点的符合条件的路径有多少条”

对于“以树的根节点为起始节点的符合条件的路径有多少条”的问题，我们假设根节点的 value 为 v，目标定值为 target，这个问题又相当于求左右子树“以树的根节点为起始节点的、路径节点和为 target=target-v 的路径有多少条” 的问题；递归时，递归函数返回路径条数，对于某个节点如果等于当时的 target，递归函数返回 “1 + 左右子树的递归结果”，否则返回 “0 + 左右子树的递归结果”

> 对于这种求解二叉树中以“根节点为起始有多少条路径”的问题，好像都可以是这种模式，遍历到某个节点的时候如果满足当时条件就返回 “1 + 左右子树的递归结果”，否则返回 “0 + 左右子树的递归结果”，因为只有满足条件的路径的最后一个节点会有个 “1”，路径上的其他节点都只会往上加 “0”，所以 “1” 的个数就是路径个数

##### 给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树

本质上就是要递归删除二叉树的对应节点。为了做到这一点，我们递归遍历左右子树的根节点看看其要不要被删除。如果对应子树的根节点需要被删除，需要将对应左右儿子的位置设置为空，反之，左右儿子应该依旧是左右儿子。然后在删除节点时，我们需要记录 “父节点被删除，但左右儿子不需要被删除的所有子树的根节点”

所以递归函数返回值为对应树的根节点（对应树的根节点不需要被删除）或者 NIL（对应树的根节点需要被删除），递归左右子树时，应该用对于左右子树的递归结果赋值给左右儿子。同时，在递归函数中，如果对应树的根节点要被删除，同时左右子树的根节点不需要被删除，应该将对应左右子树的根节点记录到 “结果列表” 中

> 在这个题目中递归函数不再是返回结果了，而是为了进行“删除节点”的操作。结果在遍历过程中额外用一个数组记录

##### 给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点

暂时不想仔细看，有一定规律。。。前序数组的第一个元素一定是一个子树的根节点，然后在中序的数组里去找，左右两边的元素数目就是左子树和右子树的元素数目之和。用递归的方式构造二叉树，跟上面删除二叉树节点的操作类似，递归函数返回结果是对应子树的根节点

##### 给定一个二叉查找树和两个整数 *L* 和 *R*，且 *L* < *R*，试修剪此二叉查找树，使得修剪后所有节点的值都在 [*L*, *R*] 的范围内

还是涉及到删除节点的问题，用递归的思路考虑。与上面删除节点相同，递归函数返回删除后子树根节点

在递归函数中，对于每个子树，如果其根节点的值大于 R，那当前子树的修剪结果等价于其左子树修剪所有节点后的结果；如果其根节点的值小于 L，那当前子树的修剪结果等价于其右子树修剪所有节点后的结果；如果其根节点就在 [L, R] 范围内，则返回当前子树的根节点，并且分别修剪其左右子树