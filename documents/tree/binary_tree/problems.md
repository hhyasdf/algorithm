#### 记录一些常见的二叉树（面试）问题 ####



##### 求二叉树中两个节点的最近公共祖先 #####

当二叉树为二叉搜索树时，问题变得简单一些。因为我们需要找到第一个两个已知节点分别处于其左子树和右子树的子树的根节点；在二叉搜索树中，如果这种情况发生，那么*根节点的值的大小会处于两个已知节点的中间*。所以我们只需要从根节点开始比较根节点与两个已知节点的值，如果根节点大于两个已知节点，那么就用左儿子继续与两个已知节点比较；如果根节点小于两个已知节点，那么就用右儿子继续与两个已知节点比较；递归进行，直到找到第一个大小在两个已知节点之间的节点，并返回。

当二叉树为一般的二叉搜索树时（也适用于一般的树），情况变得比较麻烦。我们可以忽略其它所有的节点，只剩下两个节点到根节点的路径上的节点，此时问题就变成了求一个Y字形交叉链表的第一个公共节点，我们只需要知道从两个已知节点分别到根节点的路径长度。此时我们得到了一个路径长度差，然后我们设置两个起始位置指针，并使较长的路径上的起始指针先走两条路径的长度差个位置，然后两个指针同时一步步前进，并返回两指针指向的第一个相同节点。如果每个节点中存在一个指向父节点的指针，上述思路即可解决问题。否则我们需要使用一个栈分别将从根节点到两个已知节点的路径记录下来，然后同样将较长路径的栈先 pop 出两条路径相差的个数的节点，然后一起 pop，并返回第一个 pop 出来相同的节点。

##### 求二叉树中两个节点的距离 #####

可以转化成求最近公共祖先的问题（添加一些计数器即可）；

##### 求二叉树中任意两个节点的最大距离 #####

我们需要意识到，最大距离只可能存在两个节点都为叶子节点的时候。然后问题就变成了求一个树中某个节点的左右子树高度最大和的问题。我们需要遍历每个节点，求每个左右子树高度和加1，并维持一个最大值的记录，然后输出该记录即可。