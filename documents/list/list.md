#### 记录一些常见的链表（面试）问题 ####



##### 单向链表的转置 #####

转置单向链表的基本思路是：因为转置的过程中需要记录下一个需要转置的节点的位置（无法再通过上一个节点的next域找到下一个节点），所以需要用到 3 个指针（两个作为辅助），并且要从原始链表的头节点开始进行操作（因为循环的解法比较好写，这里只写递归的写法）：

```
//一次转置两个节点，使next指向pre，然后递归操作
reverse_list_op(pre, next):
	if next == NIL:
		return pre
	nnext = next.next
	next.next = pre
	return reverse_list_op(next, nnext)             //尾递归优化

//转置的主函数
//head为链表的第一个元素，返回转置后链表的第一个元素
reverse_list(head):
	new_head = NIL
	if head != NIL:
		new_head = reverse_list_op(head, head.next)
		head.next = NIL
	return new_head
```

> PS：尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，大多数编译器会利用这个特性，优化掉函数调用时压栈出栈的损失（就只需要叠套一个堆栈空间，因为只需要将函数的参数改变再重新调用一次），缩减了递归调用需要的栈空间并且提高了程序执行效率。在gcc中用了-O2或者-O3优化选项之后，就会对尾递归进行优化。



##### 判断一个链表中是否有环 #####

一个比较经典的面试题，通过使用两个指针，指针 p1 每次移动一步，指针 p2 每次移动两步，如果在两个指针指向一个节点之前 p2 到达了链表尾部，即没有环；否则存在环，并且 p1、p2 能够相遇。要注意一些边界条件的处理。 



##### 查找一个包含环的链表中环的入口节点 #####

同样使用两个指针，指针 p1 每次移动一步，指针 p2 每次移动两步。当两个指针相遇时，p2 比 p1 多走的步数即为环的大小的整数倍（考虑进入环之前 p2 与 p1 所走的步数相同，进入环后直到相遇，p2 正好比 p1 多走了整数圈，*注意此时我们还不能得到环的准确大小*），如果没有相遇则链表中不存在环。接着我们再让 p1 和 p2 按之前的规则继续走（从刚刚相遇的地方开始，再次开始步数统计），直到两个指针再次相遇，此时 p2 与 p1 所走的步数差即为环的大小。然后问题类似于找到链表的倒数第 k 个节点（k为环的大小），我们使 p1 再次从链表头部开始，并让 p2 从链表头部数的第 k+1 个节点开始，两个指针同时每次前进一步，直到两个指针相遇，这个相遇的节点就是环的入口节点。（分为三步）

