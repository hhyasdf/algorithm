#### 记录一些常见的链表（面试）问题 ####



##### 单向链表的转置 #####

转置单向链表的基本思路是：因为转置的过程中需要记录下一个需要转置的节点的位置（无法再通过上一个节点的next域找到下一个节点），所以需要用到 3 个指针（两个作为辅助），并且要从原始链表的头节点开始进行操作（因为循环的解法比较好写，这里只写递归的写法）：

```
//一次转置两个节点，使next指向pre，然后递归操作
reverse_list_op(pre, next):
	if next == NIL:
		return pre
	nnext = next.next
	next.next = pre
	return reverse_list_op(next, nnext)             //尾递归优化

//转置的主函数
//head为链表的第一个元素，返回转置后链表的第一个元素
reverse_list(head):
	new_head = NIL
	if head != NIL:
		new_head = reverse_list_op(head, head.next)
		head.next = NIL
	return new_head
```

> PS：尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，大多数编译器会利用这个特性，优化掉函数调用时压栈出栈的损失（就只需要叠套一个堆栈空间，因为只需要将函数的参数改变再重新调用一次），缩减了递归调用需要的栈空间并且提高了程序执行效率。在gcc中用了-O2或者-O3优化选项之后，就会对尾递归进行优化。