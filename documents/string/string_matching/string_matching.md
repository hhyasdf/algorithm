#### 字符串匹配 ####

字符串匹配用得很多，总结一下。

##### 暴力查找 #####

考虑一般情况下没有任何优化的字符串匹配。我们需要在一个长度为 t 的目标串中查找长度为 s 的模式串，最简单的方式就是将每一个目标串中长度为 s 的子串与模式串比较，即，使用一个长度为s的窗口从目标串开始逐步移动到目标串尾部，并比较窗口中的子串和模式串。这个算法复杂度为 O($t*s$)。考虑到 s 的值可能很大，所以这个算法并不是很高效。

##### Rorbin-Karp算法 #####

Rorbin-Karp算法对暴力查找算法进行了优化，它保留了前一个子串的部分信息来优化下一步的比较操作。基本思想是通过hash比较每个子串与模式串，并且后一个子串的hash值可以由前一个子串的hash值算出，从而优化了每个比较操作的时间。基本思路如下：

* yi将每个字符看成是一个数字，模式串 P[1:m] 可以看成是一个M进制的数，该数的每一位即为P中的一个字符。一般M的值取决于字符的编码，且M的值要大于等于字符的范围。
* 模式串的hash值可以这样算出：$p = P[m] + M*(P[m-1] + M*(P[m-2] + ... + M*(P[2] + M*P[1])...))$，同理，子串的hash值 $t_s$ 也可以这样算出（$t_s$表示在目标串T[1:n]中，T[s: s+m-1]）。整个hash算法是 O($n$) 的。
* 当我们（假设是从左到右）右移一次窗口时，$t_{s+1}$ 满足递归式：$t_{s+1} = M*(t_s - M^{m-1}*T[s]) + T[s+m]$。

算法存在一个问题是 $p$ 和 $t_s$ 的值可能很大，这样我们就无法保证每次比较操作是常数时间复杂度的。幸运的是我们可以很容易地解决这个问题。可以选取一个合适的模 $q$ 来计算 $p$ 和 $t_s$ 的模。如果选模 $q$ 为一个素数，使得 $M*q$ 在一个计算机字长之内（保证计算 $p$ 时每次乘法都只需要一个指令），那么可以用单精度算数运算执行所有必要的运算。此时，$p = p \mod{q}=((...((((P[1]\mod{q})*M + P[2])\mod{q})*M) + P[3]...\mod{q}) + P[m])\mod{q}$

此时，$t_1$ 算法与 $p$ 相同，但递归式需要改为：$t_{s+1} = (M*(t_s - T[s]*M^{m-1}\mod{q})\mod{q} + T[s+m])\mod{q}$

（注意取模运算的运算性质）这样我们就保证了 $p$ 和 $t_s$ 不至于太过巨大。但取余操作也带来了一个问题：哈希冲突；当 $p == t_s$ 时，T[s:s+m-1]子串不一定与模式串P相等，仍需要一次额外的逐个比较两个字符串才能最终断定 子串是否与模式串相等。当每次比较hash值都发生冲突时达到最坏情况，此时时间复杂度为 O($m(n-m+1)$)。

Rorbin-Karp 算法的优化在于，计算 $p$ 和 $t_1$ 的时间是 O($m$) 的，之后每次比较和计算 $t_{s+1}$ 的复杂度为 O(1)，大大加快了比较中算数操作的速度。预处理时间为 O($m$)，比较时间为 O($n-m+1$)，所以理想情况下算法的复杂度为 O($n$)。

##### KMP算法 #####

KMP算法实际上也是通过保留上一次比较的部分信息来避免不必要的比较，从而增加字符串匹配的效率。在常规方法中，我们通过一个字符一个字符地移动比较窗口来进行字符串匹配，但实际上我们忽略了模式串中已经有部分子串已经进行了比较并且我们可以直接从这部分已经比较过了的子串开始比较。

KMP算法的核心在于：利用**模式串本身的一种属性**，即计算模式串中每一个位置之前的字符串的前缀和后缀公共部分的最大长度（***不包括字符串本身***，否则最大长度始终是字符串本身），从而，在某一个位置比较失败后，可以找到与该处位置之前的字符串的后缀相同的模式串前缀，然后在该前缀之后重新开始比较。（当不存在相同的前后缀时，则可以最大幅度地移动比较窗口，而不是一个一个字符地移动）

为了获得模式串的这个性质，我们需要一个next数组，数组长度与模式串数组相同，每一个元素记录了在该处比较失败后下一个应该比较的模式串的位置。（next[0]=-1，next[1]=0，如果next[i]为-1，则用目标串中的下一个字符与模式串开始位置比较）

在这里要注意一点，假设我们现在已经求得next[1]、next[2]、……next[i]，next中每个元素也可以分别表示长度为1到i的字符串的前缀和后缀最大公共长度，现在要**求next[i+1]**。由上图我们可以看到，**如果位置i和位置next[i]处的两个字符相同**（下标从零开始），**则next[i+1]等于next[i]加1**。**如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度next[next[i]]，然后再和位置i的字符比较**。这是因为长度为next[i]前缀和后缀都可以分割成上部的构造，如果位置next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为next[next[i]]的字符串，直到next[...next[i]...]为-1为止，此时next[i+1]=0。