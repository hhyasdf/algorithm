#### 字符串匹配 ####

字符串匹配用得很多，总结一下。

##### 暴力查找 #####

考虑一般情况下没有任何优化的字符串匹配。我们需要在一个长度为 t 的目标串中查找长度为 s 的模式串，最简单的方式就是将每一个目标串中长度为 s 的子串与模式串比较，即，使用一个长度为s的窗口从目标串开始逐步移动到目标串尾部，并比较窗口中的子串和模式串。这个算法复杂度为 O($t*s$)。考虑到 s 的值可能很大，所以这个算法并不是很高效。

##### Rorbin-Karp算法 #####

Rorbin-Karp算法对暴力查找算法进行了优化，它保留了前一个子串的部分信息来优化下一步的比较操作。基本思想是通过hash比较每个子串与模式串，并且后一个子串的hash值可以由前一个子串的hash值算出，从而优化了每个比较操作的时间。基本思路如下：

* 将每个字符看成是一个数字，模式串 P[1:m] 可以看成是一个M进制的数，该数的每一位即为P中的一个字符。一般M的值取决于字符的编码，且M的值要大于等于字符的范围。
* 模式串的hash值可以这样算出：$p = P[m] + M*(P[m-1] + M*(P[m-2] + ... + M*(P[2] + M*P[1])...))$，同理，子串的hash值 $t_s$ 也可以这样算出（$t_s$表示在目标串T[1:n]中，T[s: s+m-1]）。整个hash算法是 O($n$) 的。
* 当我们（假设是从左到右）右移一次窗口时，$t_{s+1}$ 满足递归式：$t_{s+1} = M*(t_s - M^{m-1}*T[s]) + T[s+m]$。

算法存在一个问题是 $p$ 和 $t_s$ 的值可能很大，这样我们就无法保证每次比较操作是常数时间复杂度的。幸运的是我们可以很容易地解决这个问题。可以选取一个合适的模 $q$ 来计算 $p$ 和 $t_s$ 的模。如果选模 $q$ 为一个素数，使得 $M*q$ 在一个计算机字长之内（保证计算 $p$ 时每次乘法都只需要一个指令），那么可以用单精度算数运算执行所有必要的运算。此时，$p = p \mod{q}=((...((((P[1]\mod{q})*M + P[2])\mod{q})*M) + P[3]...\mod{q}) + P[m])\mod{q}$

此时，$t_1$ 算法与 $p$ 相同，但递归式需要改为：$t_{s+1} = (M*(t_s - T[s]*M^{m-1}\mod{q})\mod{q} + T[s+m])\mod{q}$

（注意取模运算的运算性质）这样我们就保证了 $p$ 和 $t_s$ 不至于太过巨大。但取余操作也带来了一个问题：哈希冲突；当 $p == t_s$ 时，T[s:s+m-1]子串不一定与模式串P相等，仍需要一次额外的逐个比较两个字符串才能最终断定 子串是否与模式串相等。当每次比较hash值都发生冲突时达到最坏情况，此时时间复杂度为 O($m(n-m+1)$)。

Rorbin-Karp 算法的优化在于，计算 $p​$ 和 $t_1​$ 的时间是 O($m​$) 的，之后每次比较和计算 $t_{s+1}​$ 的复杂度为 O(1)，大大加快了比较中算数操作的速度。预处理时间为 O($m​$)，比较时间为 O($n-m+1​$)，所以理想情况下算法的复杂度为 O($n​$)。