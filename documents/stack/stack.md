#### 记录一些常见的栈（面试）问题 ####



##### 双栈实现队列 #####

基本问题比较简单，用两个栈，一个栈作为缓冲。每次enqueue操作push到第一个栈中，如果第一个栈满了，就把第一个栈中的元素一个个pop出来，然后push到第二个栈中直到第二个栈满，如果两个栈都是满的就阻塞（用条件变量cond）直到调用了pop或直接返回错误；每次dequeue操作从第二个栈中pop出一个元素，如果第二个栈是空的，就将第一个栈中的元素全部push到第二个栈中，然后从第二个栈中pop；如果两个栈都是空的，那么就阻塞直到调用了push或直接返回错误。

问题复杂在要实现线程友好的版本。最简单的加锁是把整个dequeue和enqueue操作加锁，效率会很低，如果想要提高效率的话就需要减小锁的粒度，即在两个栈上加锁。如果按照基本问题的思路来进行dequeue和enqueue操作的话，当第一个栈满、第二个栈为空时同时进行dequeue和enqueue操作会发生死锁问题。

要解决死锁问题，第一种方法是在enqueue操作中，如果第一个栈满了，不主动将元素push到第二个栈，（此时两个栈仍然都需要一把锁，因为可能用多个pop同时发生），如果第一个栈满了就在条件变量上（并释放已加的锁，**phread_cond_wait() 会原地释放与条件变量绑定的互斥量**）等待dequeu操作来清空第一个栈并唤醒（相应的也可以在dequeue操作中不主动清空第一个栈，操作是对称的，不再讨论）。但是这种方案在连续的push操作加连续的pop操作的情况下可能效率不能拉满。

第二种方法是用trylock在死锁的边缘试探，两把锁加两个条件变量。

enqueue操作按顺序先加第一个栈的锁，如果第一个栈满了，再trylock第二个栈的锁，如果trylock失败，就在第一个条件变量上等待（并释放第一把锁），否则，把第一个栈中的元素一个个pop出来再push到第二个栈中直到第二个栈满；同样，dequeue操作按顺序先加第二个栈的锁，如果第二个栈是空的，再加第一个栈的锁，如果trylock失败，就在第二个条件变量上等待（并释放第二把锁），否则将第一个栈中的元素全部push到第二个栈中。可能产生的问题是两个操作都trylock失败，为了避免这个问题，我们在enqueue（dequeue）操作中，trylock失败等待cond之前唤醒在第二（一）个条件变量上的所有操作。并且在每次enqueue（dequeue）操作完成之后唤醒在第二（一）个条件变量上的所有操作。如果需要实现阻塞的enqueue（dequeue）操作，那么在两次成功加锁后，如果两个栈都是满（空）的，就释放所有已加锁并在第一（二）个条件变量上等待，并唤醒第二（一）个条件变量上的所有操作。

（有空应该写下）